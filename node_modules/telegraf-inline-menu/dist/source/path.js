"use strict";
// Trigger are catching paths
// A menu is having a trigger. When a specific path is matching the trigger, the menu is opened.
// Example: The Trigger /\/events\/e-(.+)\/delete/ will get triggered when the path is called: /events/e-42/delete
Object.defineProperty(exports, "__esModule", { value: true });
exports.getMenuOfPath = exports.combinePath = exports.ensurePathMenu = exports.ensureRootMenuTrigger = exports.combineTrigger = exports.ensureTriggerLastChild = exports.ensureTriggerChild = void 0;
function ensureTriggerChild(trigger) {
    const source = typeof trigger === 'string' ? trigger : trigger.source;
    if (source.includes('/') || source.startsWith('..')) {
        throw new Error('actions are not relative. They have to be below the menu (dont contain / or ..)');
    }
}
exports.ensureTriggerChild = ensureTriggerChild;
function ensureTriggerLastChild(trigger) {
    ensureTriggerChild(trigger);
    const source = typeof trigger === 'string' ? trigger : trigger.source;
    if (!source.endsWith('$')) {
        throw new Error('actions are meant for buttons, the leaves of the menu tree. Regex ends with $: /button$/');
    }
}
exports.ensureTriggerLastChild = ensureTriggerLastChild;
function combineTrigger(parent, child) {
    if (!parent.source.startsWith('^')) {
        throw new Error('the path has to begin from start in order to prevent mistakes: /^somethingâ€¦\\//');
    }
    if (!parent.source.endsWith('/')) {
        throw new Error('the path of the menu has to be supplied. Menu paths end with /');
    }
    if (typeof child !== 'string' && child.flags) {
        throw new Error('flags will not be merged');
    }
    return new RegExp(parent.source + (typeof child === 'string' ? child : child.source), parent.flags);
}
exports.combineTrigger = combineTrigger;
function ensureRootMenuTrigger(trigger) {
    if (!trigger.source.endsWith('/')) {
        throw new Error('the root menu trigger always has to end with a slash: /');
    }
    if (!trigger.source.startsWith('^')) {
        throw new Error('The root menu trigger always has to start with a ^');
    }
    // TODO: this is not ideal yet
    // Counting / in the source doesnt work as /^[^/]+\// would be wrong and /^.+\// would still be correct
    const regex = new RegExp(trigger.source + '$', trigger.flags);
    if (regex.test('lala/lala/') || regex.test('//')) {
        throw new Error('The root menu trigger can only trigger exactly one slash as each slash represents a submenu /');
    }
}
exports.ensureRootMenuTrigger = ensureRootMenuTrigger;
function ensurePathMenu(path) {
    if (path === '') {
        throw new Error('an empty string is not a path');
    }
    if (!path.endsWith('/')) {
        throw new Error('the path of a menu has to be supplied. Menu paths end with /');
    }
}
exports.ensurePathMenu = ensurePathMenu;
function combinePath(parent, relativePath) {
    if (relativePath === '') {
        throw new Error('an empty string is not a relative path');
    }
    if (relativePath.startsWith('./')) {
        throw new Error('the path can start without prefixing it with ./ When navigating to the current menu use an empty string or . (dot)');
    }
    if (relativePath.startsWith('/')) {
        return relativePath;
    }
    const parentSegments = parent.split('/');
    if (relativePath.startsWith('..')) {
        let restOfRelative = relativePath.slice(2);
        if (restOfRelative.startsWith('/')) {
            restOfRelative = restOfRelative.slice(1);
        }
        const newParent = parentSegments.slice(0, -2).join('/') + '/';
        if (restOfRelative === '') {
            return newParent;
        }
        return combinePath(newParent, restOfRelative);
    }
    const newParent = parentSegments.slice(0, -1).join('/') + '/';
    if (relativePath === '.') {
        return newParent;
    }
    return newParent + relativePath;
}
exports.combinePath = combinePath;
function getMenuOfPath(path) {
    if (!path.includes('/')) {
        throw new Error('This does not seem like a path. Paths contain slashes to seperate the submenus.');
    }
    return combinePath(path, '.');
}
exports.getMenuOfPath = getMenuOfPath;
//# sourceMappingURL=path.js.map